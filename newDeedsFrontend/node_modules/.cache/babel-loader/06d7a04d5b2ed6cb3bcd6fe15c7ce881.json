{"ast":null,"code":"/* eslint-disable no-underscore-dangle, no-param-reassign */\nimport { isJsonRpcResponsePayload } from '../util/type-guards';\nimport { getPayloadId } from '../util/get-payload-id';\nvar payloadPreprocessedSymbol = Symbol('Payload pre-processed by Magic SDK');\n/**\n * To avoid \"pre-processing\" a payload more than once (and needlessly\n * incrementing our payload ID generator), we attach a symbol to detect a\n * payloads we've already visited.\n */\n\nfunction markPayloadAsPreprocessed(payload) {\n  Object.defineProperty(payload, payloadPreprocessedSymbol, {\n    value: true,\n    enumerable: false\n  });\n  return payload;\n}\n/**\n * Returns `true` if the payload has been visited by our \"pre-processing,\" in\n * `standardizeJsonRpcRequestPayload(...)`.\n */\n\n\nfunction isPayloadPreprocessed(payload) {\n  return !!payload[payloadPreprocessedSymbol];\n}\n/**\n * Returns a full `JsonRpcRequestPayload` from a potentially incomplete payload\n * object. This method mutates the given `payload` to preserve compatibility\n * with external libraries that perform their own `JsonRpcRequestPayload.id`\n * check to associate responses (such as `web3`).\n *\n * This function is no-op if the payload has already been processed before.\n */\n\n\nexport function standardizeJsonRpcRequestPayload(payload) {\n  var _a, _b, _c;\n\n  if (!isPayloadPreprocessed(payload)) {\n    payload.jsonrpc = (_a = payload.jsonrpc) !== null && _a !== void 0 ? _a : '2.0';\n    payload.id = getPayloadId();\n    payload.method = (_b = payload.method) !== null && _b !== void 0 ? _b : 'noop';\n    payload.params = (_c = payload.params) !== null && _c !== void 0 ? _c : [];\n    markPayloadAsPreprocessed(payload);\n  }\n\n  return payload;\n}\n/**\n * Build a valid JSON RPC payload for emitting to the Magic SDK iframe relayer.\n */\n\nexport function createJsonRpcRequestPayload(method, params) {\n  if (params === void 0) {\n    params = [];\n  }\n\n  return markPayloadAsPreprocessed({\n    params: params,\n    method: method,\n    jsonrpc: '2.0',\n    id: getPayloadId()\n  });\n}\n/**\n * Formats and standardizes a JSON RPC 2.0 response from a number of potential\n * sources.\n */\n\nvar JsonRpcResponse =\n/** @class */\nfunction () {\n  function JsonRpcResponse(responseOrPayload) {\n    if (responseOrPayload instanceof JsonRpcResponse) {\n      this._jsonrpc = responseOrPayload.payload.jsonrpc;\n      this._id = responseOrPayload.payload.id;\n      this._result = responseOrPayload.payload.result;\n      this._error = responseOrPayload.payload.error;\n    } else if (isJsonRpcResponsePayload(responseOrPayload)) {\n      this._jsonrpc = responseOrPayload.jsonrpc;\n      this._id = responseOrPayload.id;\n      this._result = responseOrPayload.result;\n      this._error = responseOrPayload.error;\n    } else {\n      this._jsonrpc = responseOrPayload.jsonrpc;\n      this._id = responseOrPayload.id;\n      this._result = undefined;\n      this._error = undefined;\n    }\n  }\n\n  JsonRpcResponse.prototype.applyError = function (error) {\n    this._error = error;\n    return this;\n  };\n\n  JsonRpcResponse.prototype.applyResult = function (result) {\n    this._result = result;\n    return this;\n  };\n\n  Object.defineProperty(JsonRpcResponse.prototype, \"hasError\", {\n    get: function () {\n      return typeof this._error !== 'undefined' && this._error !== null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(JsonRpcResponse.prototype, \"hasResult\", {\n    get: function () {\n      return typeof this._result !== 'undefined';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(JsonRpcResponse.prototype, \"payload\", {\n    get: function () {\n      return {\n        jsonrpc: this._jsonrpc,\n        id: this._id,\n        result: this._result,\n        error: this._error\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return JsonRpcResponse;\n}();\n\nexport { JsonRpcResponse };","map":null,"metadata":{},"sourceType":"module"}