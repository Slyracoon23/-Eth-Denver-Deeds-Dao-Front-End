{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { createJsonRpcRequestPayload, standardizeJsonRpcRequestPayload } from '../core/json-rpc';\nimport { BaseModule } from './base-module';\nimport { createExtensionNotInitializedError, MagicExtensionError, MagicExtensionWarning } from '../core/sdk-exceptions';\nimport { createPromiEvent, encodeJSON, decodeJSON, encodeQueryParameters, decodeQueryParameters, storage, isPromiEvent } from '../util';\n\nvar BaseExtension =\n/** @class */\nfunction (_super) {\n  __extends(BaseExtension, _super);\n\n  function BaseExtension() {\n    var _this = _super.call(this, undefined) || this;\n\n    _this.isInitialized = false;\n    _this.utils = {\n      createPromiEvent: createPromiEvent,\n      isPromiEvent: isPromiEvent,\n      encodeJSON: encodeJSON,\n      decodeJSON: decodeJSON,\n      encodeQueryParameters: encodeQueryParameters,\n      decodeQueryParameters: decodeQueryParameters,\n      createJsonRpcRequestPayload: createJsonRpcRequestPayload,\n      standardizeJsonRpcRequestPayload: standardizeJsonRpcRequestPayload,\n      storage: storage\n    };\n    var sdkAccessFields = ['request', 'transport', 'overlay', 'sdk']; // Disallow SDK access before initialization.\n\n    return new Proxy(_this, {\n      get: function (target, prop, receiver) {\n        if (sdkAccessFields.includes(prop) && !_this.isInitialized) {\n          throw createExtensionNotInitializedError(prop);\n        }\n\n        return Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n  /**\n   * Registers a Magic SDK instance with this Extension.\n   */\n\n\n  BaseExtension.prototype.init = function (sdk) {\n    if (this.isInitialized) return;\n    this.sdk = sdk;\n    this.isInitialized = true;\n  };\n  /**\n   * Creates a deprecation warning wrapped with a native Magic SDK warning type.\n   * Best practice is to warn users of upcoming deprecations at least one major\n   * version before the change is implemented. You can use this method to\n   * communicate deprecations in a manner consistent with Magic SDK core code.\n   */\n\n\n  BaseExtension.prototype.createDeprecationWarning = function (options) {\n    var method = options.method,\n        removalVersion = options.removalVersion,\n        useInstead = options.useInstead;\n    var useInsteadSuffix = useInstead ? \" Use `\" + useInstead + \"` instead.\" : '';\n    var message = \"`\" + method + \"` will be removed from this Extension in version `\" + removalVersion + \"`.\" + useInsteadSuffix;\n    return new MagicExtensionWarning(this, 'DEPRECATION_NOTICE', message);\n  };\n  /**\n   * Creates a warning wrapped with a native Magic SDK warning type. This\n   * maintains consistency in warning messaging for consumers of Magic SDK and\n   * this Extension.\n   */\n\n\n  BaseExtension.prototype.createWarning = function (code, message) {\n    return new MagicExtensionWarning(this, code, message);\n  };\n  /**\n   * Creates an error wrapped with a native Magic SDK error type. This maintains\n   * consistency in error handling for consumers of Magic SDK and this\n   * Extension.\n   */\n\n\n  BaseExtension.prototype.createError = function (code, message, data) {\n    return new MagicExtensionError(this, code, message, data);\n  };\n  /**\n   * Throws an error wrapped with a native Magic SDK error type. This maintains\n   * consistency in error handling for consumers of Magic SDK and this\n   * Extension.\n   */\n\n\n  BaseExtension.prototype.raiseError = function (code, message, data) {\n    throw new MagicExtensionError(this, code, message, data);\n  };\n\n  return BaseExtension;\n}(BaseModule);\n\nvar InternalExtension =\n/** @class */\nfunction (_super) {\n  __extends(InternalExtension, _super);\n\n  function InternalExtension() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return InternalExtension;\n}(BaseExtension);\n\nvar Extension =\n/** @class */\nfunction (_super) {\n  __extends(Extension, _super);\n\n  function Extension() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * This is a special constructor used to mark an extension as \"official.\" Only\n   * official extensions can interact with the iframe using custom JSON RPC\n   * methods and business logic. This is intended for internal-use only and\n   * provides no advantage to open-source extension developers.\n   *\n   * @internal\n   */\n\n\n  Extension.Internal = InternalExtension;\n  return Extension;\n}(BaseExtension);\n\nexport { Extension };","map":null,"metadata":{},"sourceType":"module"}