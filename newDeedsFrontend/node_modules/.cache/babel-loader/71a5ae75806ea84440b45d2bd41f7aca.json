{"ast":null,"code":"import { createTypedEmitter } from './events';\nvar promiEventBrand = Symbol('isPromiEvent');\n/**\n * Returns `true` if the given `value` is a `PromiEvent`.\n */\n\nexport function isPromiEvent(value) {\n  return !!value[promiEventBrand];\n}\n/**\n * Create a native JavaScript `Promise` overloaded with strongly-typed methods\n * from `EventEmitter`.\n */\n\nexport function createPromiEvent(executor) {\n  var promise = createAutoCatchingPromise(executor);\n\n  var _a = createTypedEmitter(),\n      createBoundEmitterMethod = _a.createBoundEmitterMethod,\n      createChainingEmitterMethod = _a.createChainingEmitterMethod; // We save the original `Promise` methods to the following symbols so we can\n  // access them internally.\n\n\n  var thenSymbol = Symbol('Promise.then');\n  var catchSymbol = Symbol('Promise.catch');\n  var finallySymbol = Symbol('Promise.finally');\n  /**\n   * Ensures the next object in the `PromiEvent` chain is overloaded with\n   * `EventEmitter` methods.\n   */\n\n  var createChainingPromiseMethod = function (method, source) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var nextPromise = source[method].apply(source, args);\n      return promiEvent(nextPromise);\n    };\n  };\n  /**\n   * Builds a `PromiEvent` by assigning `EventEmitter` methods to a native\n   * `Promise` object.\n   */\n\n\n  var promiEvent = function (source) {\n    var _a;\n\n    return Object.assign(source, (_a = {}, _a[promiEventBrand] = true, _a[thenSymbol] = source[thenSymbol] || source.then, _a[catchSymbol] = source[catchSymbol] || source.catch, _a[finallySymbol] = source[finallySymbol] || source.finally, _a.then = createChainingPromiseMethod(thenSymbol, source), _a.catch = createChainingPromiseMethod(catchSymbol, source), _a.finally = createChainingPromiseMethod(finallySymbol, source), _a.on = createChainingEmitterMethod('on', source), _a.once = createChainingEmitterMethod('once', source), _a.addListener = createChainingEmitterMethod('addListener', source), _a.off = createChainingEmitterMethod('off', source), _a.removeListener = createChainingEmitterMethod('removeListener', source), _a.removeAllListeners = createChainingEmitterMethod('removeAllListeners', source), _a.emit = createBoundEmitterMethod('emit'), _a.eventNames = createBoundEmitterMethod('eventNames'), _a.listeners = createBoundEmitterMethod('listeners'), _a.listenerCount = createBoundEmitterMethod('listenerCount'), _a));\n  };\n\n  var result = promiEvent(promise.then(function (resolved) {\n    // Emit default completion events and resolve result.\n    result.emit('done', resolved);\n    result.emit('settled');\n    return resolved;\n  }, function (err) {\n    // Emit default error events and re-throw.\n    result.emit('error', err);\n    result.emit('settled');\n    throw err;\n  }));\n  return result;\n}\n/**\n * Creates a `Promise` with an **async executor** that automatically catches\n * errors occurring within the executor. Nesting promises in this way is usually\n * deemed an _anti-pattern_, but it's useful and clean when promisifying the\n * event-based code that's inherent to JSON RPC.\n *\n * So, here we solve the issue of nested promises by ensuring that no errors\n * mistakenly go unhandled!\n */\n\nexport function createAutoCatchingPromise(executor) {\n  return new Promise(function (resolve, reject) {\n    var result = executor(resolve, reject);\n    Promise.resolve(result).catch(reject);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}