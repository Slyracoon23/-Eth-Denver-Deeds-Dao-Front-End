{"ast":null,"code":"import { AbstractConnector } from '@web3-react/abstract-connector';\nimport invariant from 'tiny-invariant';\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n} // A type of promise-like that resolves synchronously and supports only one observer\n\n\nvar _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = /*#__PURE__*/Symbol(\"Symbol.iterator\")) : \"@@iterator\"; // Asynchronously iterate through an object's values\n\n\nvar _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = /*#__PURE__*/Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n} // Asynchronously await a promise and pass the result to a finally continuation\n\n\nvar chainIdToNetwork = {\n  1: 'mainnet',\n  3: 'ropsten',\n  4: 'rinkeby',\n  42: 'kovan'\n};\n\nvar UserRejectedRequestError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(UserRejectedRequestError, _Error);\n\n  function UserRejectedRequestError() {\n    var _this;\n\n    _this = _Error.call(this) || this;\n    _this.name = _this.constructor.name;\n    _this.message = 'The user rejected the request.';\n    return _this;\n  }\n\n  return UserRejectedRequestError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar FailedVerificationError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(FailedVerificationError, _Error2);\n\n  function FailedVerificationError() {\n    var _this2;\n\n    _this2 = _Error2.call(this) || this;\n    _this2.name = _this2.constructor.name;\n    _this2.message = 'The email verification failed.';\n    return _this2;\n  }\n\n  return FailedVerificationError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar MagicLinkRateLimitError = /*#__PURE__*/function (_Error3) {\n  _inheritsLoose(MagicLinkRateLimitError, _Error3);\n\n  function MagicLinkRateLimitError() {\n    var _this3;\n\n    _this3 = _Error3.call(this) || this;\n    _this3.name = _this3.constructor.name;\n    _this3.message = 'The Magic rate limit has been reached.';\n    return _this3;\n  }\n\n  return MagicLinkRateLimitError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar MagicLinkExpiredError = /*#__PURE__*/function (_Error4) {\n  _inheritsLoose(MagicLinkExpiredError, _Error4);\n\n  function MagicLinkExpiredError() {\n    var _this4;\n\n    _this4 = _Error4.call(this) || this;\n    _this4.name = _this4.constructor.name;\n    _this4.message = 'The Magic link has expired.';\n    return _this4;\n  }\n\n  return MagicLinkExpiredError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar MagicConnector = /*#__PURE__*/function (_AbstractConnector) {\n  _inheritsLoose(MagicConnector, _AbstractConnector);\n\n  function MagicConnector(_ref) {\n    var _this5;\n\n    var apiKey = _ref.apiKey,\n        chainId = _ref.chainId,\n        email = _ref.email;\n    !Object.keys(chainIdToNetwork).includes(chainId.toString()) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Unsupported chainId \" + chainId) : invariant(false) : void 0;\n    !(email && email.includes('@')) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Invalid email: \" + email) : invariant(false) : void 0;\n    _this5 = _AbstractConnector.call(this, {\n      supportedChainIds: [chainId]\n    }) || this;\n    _this5.apiKey = apiKey;\n    _this5.chainId = chainId;\n    _this5.email = email;\n    return _this5;\n  }\n\n  var _proto = MagicConnector.prototype;\n\n  _proto.activate = function activate() {\n    try {\n      var _this7 = this;\n\n      return Promise.resolve(import('magic-sdk').then(function (m) {\n        var _m$default;\n\n        return (_m$default = m == null ? void 0 : m[\"default\"]) != null ? _m$default : m;\n      })).then(function (MagicSDK) {\n        var Magic = MagicSDK.Magic,\n            RPCError = MagicSDK.RPCError,\n            RPCErrorCode = MagicSDK.RPCErrorCode;\n\n        if (!_this7.magic) {\n          _this7.magic = new Magic(_this7.apiKey, {\n            network: chainIdToNetwork[_this7.chainId]\n          });\n        }\n\n        return Promise.resolve(_this7.magic.user.isLoggedIn()).then(function (isLoggedIn) {\n          function _temp5(_this6$magic$user$get) {\n            function _temp4() {\n              var _exit = false;\n\n              function _temp2(_result2) {\n                if (_exit) return _result2;\n                var provider = _this7.magic.rpcProvider;\n                return Promise.resolve(provider.enable().then(function (accounts) {\n                  return accounts[0];\n                })).then(function (account) {\n                  return {\n                    provider: provider,\n                    chainId: _this7.chainId,\n                    account: account\n                  };\n                });\n              }\n\n              var _temp = function () {\n                if (!isLoggedIn) {\n                  return _catch(function () {\n                    return Promise.resolve(_this7.magic.auth.loginWithMagicLink({\n                      email: _this7.email\n                    })).then(function () {});\n                  }, function (err) {\n                    if (!(err instanceof RPCError)) {\n                      throw err;\n                    }\n\n                    if (err.code === RPCErrorCode.MagicLinkFailedVerification) {\n                      throw new FailedVerificationError();\n                    }\n\n                    if (err.code === RPCErrorCode.MagicLinkExpired) {\n                      throw new MagicLinkExpiredError();\n                    }\n\n                    if (err.code === RPCErrorCode.MagicLinkRateLimited) {\n                      throw new MagicLinkRateLimitError();\n                    } // This error gets thrown when users close the login window.\n                    // -32603 = JSON-RPC InternalError\n\n\n                    if (err.code === -32603) {\n                      throw new UserRejectedRequestError();\n                    }\n                  });\n                }\n              }();\n\n              return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n            }\n\n            var loggedInEmail = isLoggedIn ? _this6$magic$user$get.email : _this6$magic$user$get;\n\n            var _temp3 = function () {\n              if (isLoggedIn && loggedInEmail !== _this7.email) {\n                return Promise.resolve(_this7.magic.user.logout()).then(function () {});\n              }\n            }();\n\n            return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);\n          }\n\n          return isLoggedIn ? Promise.resolve(_this7.magic.user.getMetadata()).then(_temp5) : _temp5(null);\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getProvider = function getProvider() {\n    try {\n      var _this9 = this;\n\n      return Promise.resolve(_this9.magic.rpcProvider);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getChainId = function getChainId() {\n    try {\n      var _this11 = this;\n\n      return Promise.resolve(_this11.chainId);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getAccount = function getAccount() {\n    try {\n      var _this13 = this;\n\n      return Promise.resolve(_this13.magic.rpcProvider.send('eth_accounts').then(function (accounts) {\n        return accounts[0];\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.deactivate = function deactivate() {};\n\n  _proto.close = function close() {\n    try {\n      var _this15 = this;\n\n      return Promise.resolve(_this15.magic.user.logout()).then(function () {\n        _this15.emitDeactivate();\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return MagicConnector;\n}(AbstractConnector);\n\nexport { FailedVerificationError, MagicConnector, MagicLinkExpiredError, MagicLinkRateLimitError, UserRejectedRequestError };","map":null,"metadata":{},"sourceType":"module"}