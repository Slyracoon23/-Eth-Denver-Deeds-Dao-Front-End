{"ast":null,"code":"var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n/* eslint-disable */\n\n/* istanbul ignore next  */\n\nfunction fromByteArray(uint8) {\n  var i;\n  var extraBytes = uint8.length % 3; // if we have 1 byte left, pad 2 bytes\n\n  var output = '';\n  var temp;\n  var length;\n\n  function encode(num) {\n    return lookup.charAt(num);\n  }\n\n  function tripletToBase64(num) {\n    return encode(num >> 18 & 0x3f) + encode(num >> 12 & 0x3f) + encode(num >> 6 & 0x3f) + encode(num & 0x3f);\n  } // go through the array every three bytes, we'll deal with trailing stuff later\n\n\n  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output += tripletToBase64(temp);\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  switch (extraBytes) {\n    case 1:\n      temp = uint8[uint8.length - 1];\n      output += encode(temp >> 2);\n      output += encode(temp << 4 & 0x3f);\n      output += '==';\n      break;\n\n    case 2:\n      temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n      output += encode(temp >> 10);\n      output += encode(temp >> 4 & 0x3f);\n      output += encode(temp << 2 & 0x3f);\n      output += '=';\n      break;\n\n    default:\n      break;\n  }\n\n  return output;\n}\n/* istanbul ignore next  */\n\n\nfunction b64enc(buf) {\n  return fromByteArray(buf).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n/* istanbul ignore next  */\n\n\nfunction b64RawEnc(buf) {\n  return fromByteArray(buf).replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n/* istanbul ignore next  */\n\n\nfunction hexEncode(buf) {\n  return Array.from(buf).map(function (x) {\n    return (\"0\" + x.toString(16)).substr(-2);\n  }).join('');\n}\n/**\n * Transforms the binary data in the credential into base64 strings\n * for posting to the server.\n * @param {PublicKeyCredential} newAssertion\n */\n\n/* istanbul ignore next  */\n\n\nexport var transformNewAssertionForServer = function (newAssertion) {\n  var attObj = new Uint8Array(newAssertion.response.attestationObject);\n  var clientDataJSON = new Uint8Array(newAssertion.response.clientDataJSON);\n  var rawId = new Uint8Array(newAssertion.rawId);\n  var registrationClientExtensions = newAssertion.getClientExtensionResults();\n  return {\n    id: newAssertion.id,\n    rawId: b64enc(rawId),\n    type: newAssertion.type,\n    attObj: b64enc(attObj),\n    clientData: b64enc(clientDataJSON),\n    registrationClientExtensions: JSON.stringify(registrationClientExtensions)\n  };\n};\n/**\n * Encodes the binary data in the assertion into strings for posting to the server.\n * @param {PublicKeyCredential} newAssertion\n */\n\n/* istanbul ignore next  */\n\nexport var transformAssertionForServer = function (newAssertion) {\n  var authData = new Uint8Array(newAssertion.response.authenticatorData);\n  var clientDataJSON = new Uint8Array(newAssertion.response.clientDataJSON);\n  var rawId = new Uint8Array(newAssertion.rawId);\n  var sig = new Uint8Array(newAssertion.response.signature);\n  var assertionClientExtensions = newAssertion.getClientExtensionResults();\n  return {\n    id: newAssertion.id,\n    rawId: b64enc(rawId),\n    type: newAssertion.type,\n    authData: b64RawEnc(authData),\n    clientData: b64RawEnc(clientDataJSON),\n    signature: hexEncode(sig),\n    assertionClientExtensions: JSON.stringify(assertionClientExtensions)\n  };\n};","map":null,"metadata":{},"sourceType":"module"}