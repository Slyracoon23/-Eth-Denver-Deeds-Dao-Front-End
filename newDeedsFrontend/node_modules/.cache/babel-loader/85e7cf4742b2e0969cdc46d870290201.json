{"ast":null,"code":"import EventEmitter from \"eventemitter3\";\nimport WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport { IJsonRpcConnection } from \"@walletconnect/jsonrpc-types\";\nimport { formatJsonRpcError } from \"@walletconnect/jsonrpc-utils\";\nexport class SignerConnection extends IJsonRpcConnection {\n  constructor(opts) {\n    super();\n    this.events = new EventEmitter();\n    this.accounts = [];\n    this.chainId = 1;\n    this.pending = false;\n    this.bridge = \"https://bridge.walletconnect.org\";\n    this.qrcode = true;\n    this.qrcodeModalOptions = undefined;\n    this.opts = opts;\n    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n    this.wc = this.register(opts);\n  }\n\n  get connected() {\n    return typeof this.wc !== \"undefined\" && this.wc.connected;\n  }\n\n  get connecting() {\n    return this.pending;\n  }\n\n  get connector() {\n    this.wc = this.register(this.opts);\n    return this.wc;\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async open(chainId) {\n    if (this.connected) {\n      this.onOpen();\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      this.on(\"error\", err => {\n        reject(err);\n      });\n      this.on(\"open\", () => {\n        resolve();\n      });\n      this.create(chainId);\n    });\n  }\n\n  async close() {\n    if (typeof this.wc === \"undefined\") return;\n\n    if (this.wc.connected) {\n      this.wc.killSession();\n    }\n\n    this.onClose();\n  }\n\n  async send(payload) {\n    this.wc = this.register(this.opts);\n    if (!this.connected) await this.open();\n    this.sendPayload(payload).then(res => this.events.emit(\"payload\", res)).catch(e => this.events.emit(\"payload\", formatJsonRpcError(payload.id, e.message)));\n  }\n\n  register(opts) {\n    if (this.wc) return this.wc;\n    this.opts = opts || this.opts;\n    this.bridge = (opts === null || opts === void 0 ? void 0 : opts.connector) ? opts.connector.bridge : (opts === null || opts === void 0 ? void 0 : opts.bridge) || \"https://bridge.walletconnect.org\";\n    this.qrcode = typeof (opts === null || opts === void 0 ? void 0 : opts.qrcode) === \"undefined\" || opts.qrcode !== false;\n    this.chainId = typeof (opts === null || opts === void 0 ? void 0 : opts.chainId) !== \"undefined\" ? opts.chainId : this.chainId;\n    this.qrcodeModalOptions = opts === null || opts === void 0 ? void 0 : opts.qrcodeModalOptions;\n    const connectorOpts = {\n      bridge: this.bridge,\n      qrcodeModal: this.qrcode ? QRCodeModal : undefined,\n      qrcodeModalOptions: this.qrcodeModalOptions,\n      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta\n    };\n    this.wc = typeof (opts === null || opts === void 0 ? void 0 : opts.connector) !== \"undefined\" ? opts.connector : new WalletConnect(connectorOpts);\n\n    if (typeof this.wc === \"undefined\") {\n      throw new Error(\"Failed to register WalletConnect connector\");\n    }\n\n    if (this.wc.accounts.length) {\n      this.accounts = this.wc.accounts;\n    }\n\n    if (this.wc.chainId) {\n      this.chainId = this.wc.chainId;\n    }\n\n    this.registerConnectorEvents();\n    return this.wc;\n  }\n\n  onOpen(wc) {\n    this.pending = false;\n\n    if (wc) {\n      this.wc = wc;\n    }\n\n    this.events.emit(\"open\");\n  }\n\n  onClose() {\n    this.pending = false;\n\n    if (this.wc) {\n      this.wc = undefined;\n    }\n\n    this.events.emit(\"close\");\n  }\n\n  onError(payload) {\n    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Failed or Rejected Request\";\n    let code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -32000;\n    const errorPayload = {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      error: {\n        code,\n        message\n      }\n    };\n    this.events.emit(\"payload\", errorPayload);\n    return errorPayload;\n  }\n\n  create(chainId) {\n    this.wc = this.register(this.opts);\n    this.chainId = chainId || this.chainId;\n    if (this.connected || this.pending) return;\n    this.pending = true;\n    this.registerConnectorEvents();\n    this.wc.createSession({\n      chainId: this.chainId\n    }).then(() => this.events.emit(\"created\")).catch(e => this.events.emit(\"error\", e));\n  }\n\n  registerConnectorEvents() {\n    this.wc = this.register(this.opts);\n    this.wc.on(\"connect\", err => {\n      var _a, _b;\n\n      if (err) {\n        this.events.emit(\"error\", err);\n        return;\n      }\n\n      this.accounts = ((_a = this.wc) === null || _a === void 0 ? void 0 : _a.accounts) || [];\n      this.chainId = ((_b = this.wc) === null || _b === void 0 ? void 0 : _b.chainId) || this.chainId;\n      this.onOpen();\n    });\n    this.wc.on(\"disconnect\", err => {\n      if (err) {\n        this.events.emit(\"error\", err);\n        return;\n      }\n\n      this.onClose();\n    });\n    this.wc.on(\"modal_closed\", () => {\n      this.events.emit(\"error\", new Error(\"User closed modal\"));\n    });\n    this.wc.on(\"session_update\", (error, payload) => {\n      const {\n        accounts,\n        chainId\n      } = payload.params[0];\n\n      if (!this.accounts || accounts && this.accounts !== accounts) {\n        this.accounts = accounts;\n        this.events.emit(\"accountsChanged\", accounts);\n      }\n\n      if (!this.chainId || chainId && this.chainId !== chainId) {\n        this.chainId = chainId;\n        this.events.emit(\"chainChanged\", chainId);\n      }\n    });\n  }\n\n  async sendPayload(payload) {\n    this.wc = this.register(this.opts);\n\n    try {\n      const response = await this.wc.unsafeSend(payload);\n      return this.sanitizeResponse(response);\n    } catch (error) {\n      return this.onError(payload, error.message);\n    }\n  }\n\n  sanitizeResponse(response) {\n    return typeof response.error !== \"undefined\" && typeof response.error.code === \"undefined\" ? formatJsonRpcError(response.id, response.error.message) : response;\n  }\n\n}\nexport default SignerConnection;","map":null,"metadata":{},"sourceType":"module"}